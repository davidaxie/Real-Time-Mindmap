<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI-Powered Realtime Mindmap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
          sans-serif;
        background: #f7f4ef;
        color: #1f2933;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: radial-gradient(
            circle at top left,
            rgba(226, 232, 240, 0.6),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(244, 219, 216, 0.55),
            transparent 50%
          ),
          #f7f4ef;
      }
      header {
        padding: 2.5rem 1.5rem 1.5rem;
        text-align: center;
        color: #111827;
      }
      header h1 {
        margin: 0;
        font-size: clamp(2rem, 4vw, 2.8rem);
        font-weight: 600;
        letter-spacing: -0.03em;
      }
      header p {
        margin: 0.75rem auto 0;
        max-width: 760px;
        line-height: 1.65;
        color: rgba(55, 65, 81, 0.75);
      }
      main {
        flex: 1;
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        padding: 0 1.5rem 2.5rem;
      }
      section {
        backdrop-filter: blur(14px);
        background: rgba(255, 255, 255, 0.82);
        border: 1px solid rgba(209, 213, 219, 0.7);
        border-radius: 18px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      section h2 {
        margin: 0;
        padding: 1.2rem 1.5rem 0.75rem;
        font-size: 0.95rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: rgba(107, 114, 128, 0.9);
      }
      .section-body {
        padding: 0 1.5rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        flex: 1;
      }
      #controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      button {
        border: 1px solid rgba(99, 102, 241, 0.22);
        border-radius: 999px;
        padding: 0.65rem 1.2rem;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        color: #312e81;
        background: linear-gradient(135deg, #ede9fe, #e0e7ff);
        transition: transform 0.2s ease, box-shadow 0.2s ease,
          border-color 0.2s ease;
        box-shadow: 0 8px 18px rgba(129, 140, 248, 0.2);
      }
      button.secondary {
        background: #ffffff;
        color: #1f2933;
        border-color: rgba(209, 213, 219, 0.8);
        box-shadow: none;
      }
      button.danger {
        background: linear-gradient(135deg, #fee2e2, #fecaca);
        color: #b91c1c;
        border-color: rgba(248, 113, 113, 0.4);
        box-shadow: 0 8px 18px rgba(248, 113, 113, 0.2);
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
      }
      button:not(:disabled):hover {
        transform: translateY(-1px);
        border-color: rgba(99, 102, 241, 0.4);
      }
      .status-line {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.9rem;
        color: rgba(55, 65, 81, 0.75);
      }
      .status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #f97316;
        box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.3);
        animation: pulse 2s infinite;
      }
      .status-indicator.active {
        background: #22c55e;
        box-shadow: 0 0 0 8px rgba(34, 197, 94, 0);
      }
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.45);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
        }
      }
      .control-grid {
        display: grid;
        gap: 0.75rem 1.25rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
      .control-grid label {
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(107, 114, 128, 0.85);
      }
      .control-grid select,
      .control-grid input[type="text"],
      .control-grid input[type="range"] {
        width: 100%;
        padding: 0.55rem 0.7rem;
        border-radius: 12px;
        border: 1px solid rgba(209, 213, 219, 0.9);
        background: #fdfdfb;
        color: #1f2933;
        font-family: inherit;
      }
      .control-grid .range-value {
        font-size: 0.82rem;
        color: rgba(55, 65, 81, 0.7);
      }
      .hint {
        font-size: 0.82rem;
        color: rgba(75, 85, 99, 0.75);
        line-height: 1.5;
      }
      #live-transcript,
      #translation-live {
        min-height: 80px;
        padding: 1rem;
        border-radius: 12px;
        background: rgba(249, 250, 251, 0.9);
        border: 1px solid rgba(209, 213, 219, 0.7);
        line-height: 1.7;
        color: #1f2937;
      }
      #transcript-log,
      #translation-history {
        flex: 1;
        overflow-y: auto;
        max-height: 320px;
        padding-right: 0.75rem;
      }
      .segment,
      .translation-item {
        padding: 0.85rem 1rem;
        margin-bottom: 0.75rem;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 14px;
        border: 1px solid rgba(226, 232, 240, 0.9);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.04);
      }
      .segment time,
      .translation-item time {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(107, 114, 128, 0.7);
      }
      .segment p,
      .translation-item p {
        margin: 0.45rem 0 0;
        line-height: 1.6;
        color: #1f2937;
      }
      .translation-item .meta {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.75rem;
        color: rgba(107, 114, 128, 0.7);
        margin-top: 0.4rem;
      }
      #cy {
        width: 100%;
        flex: 1;
        min-height: 520px;
        border-top: 1px solid rgba(209, 213, 219, 0.6);
        background: rgba(241, 245, 249, 0.85);
      }
      #details {
        flex: 1;
        overflow-y: auto;
        max-height: 260px;
      }
      .detail-item {
        padding: 0.8rem 0;
        border-bottom: 1px solid rgba(226, 232, 240, 0.9);
      }
      .detail-item:last-child {
        border-bottom: none;
      }
      textarea {
        width: 100%;
        min-height: 90px;
        border-radius: 12px;
        border: 1px solid rgba(209, 213, 219, 0.9);
        background: #ffffff;
        color: #1f2933;
        padding: 0.8rem;
        font-family: inherit;
        resize: vertical;
      }
      .metric-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.3rem 0.65rem;
        border-radius: 999px;
        background: rgba(226, 232, 240, 0.8);
        color: #1f2937;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .metric-pill.danger {
        background: rgba(254, 226, 226, 0.85);
        color: #b91c1c;
      }
      .metric-pill.success {
        background: rgba(220, 252, 231, 0.85);
        color: #15803d;
      }
      .status-stack {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .status-stack small {
        color: rgba(75, 85, 99, 0.7);
      }
      .api-key-input {
        font-size: 0.85rem !important;
        font-family: monospace;
      }
      @media (max-width: 768px) {
        header {
          padding-top: 2rem;
        }
        main {
          padding-bottom: 1.5rem;
        }
        #cy {
          min-height: 420px;
        }
      }
    </style>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  </head>
  <body>
    <header>
      <h1>AI-Powered Realtime Mindmap</h1>
      <p>
        Capture discussions, lectures, and meetings as they happen. Speech is
        transcribed live, analyzed by AI to extract key concepts and themes, and
        visualised as an evolving mindmap so you can spot themes, action items,
        and emerging ideas instantly.
      </p>
    </header>
    <main>
      <section>
        <h2>Configuration</h2>
        <div class="section-body">
          <div class="control-grid">
            <div>
              <label for="model-select">Groq Model</label>
              <select id="model-select">
                <option value="llama-3.1-8b-instant">
                  Llama 3.1 8B Instant
                </option>
                <option value="llama-3.1-70b-versatile">
                  Llama 3.1 70B Versatile
                </option>
                <option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
                <option value="gemma2-9b-it">Gemma 2 9B</option>
              </select>
            </div>
          </div>
          <p class="hint">
            The API key is securely stored on the backend. Select your preferred
            AI model.
          </p>
        </div>
      </section>

      <section>
        <h2>Capture Controls</h2>
        <div class="section-body">
          <div id="controls">
            <button id="start-btn">Start Listening</button>
            <button id="pause-btn" class="secondary" disabled>Pause</button>
            <button id="stop-btn" class="danger" disabled>
              Stop &amp; Reset
            </button>
            <button id="export-btn" class="secondary" disabled>
              Export JSON
            </button>
          </div>
          <div class="status-line">
            <span id="status-indicator" class="status-indicator"></span>
            <span id="status-text">Idle • microphone permissions required</span>
          </div>
          <div class="control-grid">
            <div>
              <label for="source-lang">Source language (ASR)</label>
              <select id="source-lang"></select>
            </div>
            <div>
              <label for="note-input">Add manual note</label>
              <textarea
                id="note-input"
                placeholder="Type a note or idea and press ⌘/Ctrl + Enter"
              ></textarea>
            </div>
          </div>
          <p class="hint">
            The recogniser keeps a rolling buffer. Pause when silence exceeds a
            few seconds to help with processing.
          </p>
        </div>
      </section>

      <section>
        <h2>Live Transcript</h2>
        <div class="section-body">
          <div id="live-transcript">Waiting for speech…</div>
          <div id="transcript-log"></div>
        </div>
      </section>

      <section>
        <h2>AI Analysis</h2>
        <div class="section-body">
          <div class="status-stack" id="ai-status">
            <div class="metric-pill">Ready</div>
            <small
              >AI will analyze your speech to extract key concepts and
              themes.</small
            >
          </div>
          <div
            id="ai-output"
            style="
              min-height: 80px;
              padding: 1rem;
              border-radius: 12px;
              background: rgba(249, 250, 251, 0.9);
              border: 1px solid rgba(209, 213, 219, 0.7);
              line-height: 1.7;
              color: #1f2937;
            "
          >
            AI insights will appear here...
          </div>
        </div>
      </section>

      <section style="grid-column: 1 / -1; min-height: 640px">
        <h2>Mindmap</h2>
        <div id="cy"></div>
      </section>

      <section>
        <h2>Focus Panel</h2>
        <div class="section-body" id="details">
          <p>
            Select a node in the mindmap to see the most recent notes and quotes
            linked to it.
          </p>
        </div>
      </section>
    </main>

    <script>
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;

      const statusIndicator = document.getElementById("status-indicator");
      const statusText = document.getElementById("status-text");
      const startBtn = document.getElementById("start-btn");
      const pauseBtn = document.getElementById("pause-btn");
      const stopBtn = document.getElementById("stop-btn");
      const exportBtn = document.getElementById("export-btn");
      const liveTranscript = document.getElementById("live-transcript");
      const transcriptLog = document.getElementById("transcript-log");
      const noteInput = document.getElementById("note-input");
      const detailsPanel = document.getElementById("details");
      const sourceLangSelect = document.getElementById("source-lang");
      const modelSelect = document.getElementById("model-select");
      const aiOutput = document.getElementById("ai-output");
      const aiStatus = document.getElementById("ai-status");

      const STOPWORDS = new Set([
        "the",
        "a",
        "an",
        "and",
        "or",
        "of",
        "to",
        "in",
        "for",
        "on",
        "with",
        "at",
        "by",
        "is",
        "are",
        "be",
        "we",
        "you",
        "i",
        "it",
        "that",
        "this",
        "as",
        "our",
        "your",
        "from",
        "about",
        "was",
        "were",
        "have",
        "has",
        "had",
        "will",
        "would",
        "can",
        "could",
        "should",
        "they",
        "them",
        "their",
        "but",
        "if",
        "not",
        "so",
      ]);

      const LANGUAGE_OPTIONS = [
        { code: "auto", label: "Auto detect" },
        { code: "en-US", label: "English (United States)" },
        { code: "en-GB", label: "English (United Kingdom)" },
        { code: "es-ES", label: "Spanish" },
        { code: "fr-FR", label: "French" },
        { code: "de-DE", label: "German" },
        { code: "pt-BR", label: "Portuguese (Brazil)" },
        { code: "it-IT", label: "Italian" },
        { code: "hi-IN", label: "Hindi" },
        { code: "ja-JP", label: "Japanese" },
        { code: "zh-CN", label: "Chinese (Mandarin)" },
      ];

      const graph = {
        nodes: new Map(),
        edges: new Map(),
      };

      const segments = [];
      const recentTranscripts = [];
      const maxTranscriptBuffer = 10;
      let cy;
      let recognition;
      let isPaused = false;
      let isCapturing = false;
      let allowAutoRestart = false;
      let aiAnalysisPending = false;
      let aiAnalysisQueue = [];

      // Backend API is now handling the API key securely

      function initCytoscape() {
        cy = cytoscape({
          container: document.getElementById("cy"),
          elements: [],
          layout: { name: "cose", animate: true, padding: 40 },
          style: [
            {
              selector: "node",
              style: {
                label: "data(label)",
                "text-valign": "center",
                "font-size": "mapData(weight, 0, 40, 10, 28)",
                color: "#1f2937",
                "background-color": "mapData(weight, 0, 40, #c7d2fe, #fbbf24)",
                width: "mapData(weight, 0, 40, 26, 100)",
                height: "mapData(weight, 0, 40, 26, 100)",
                "text-outline-width": 1,
                "text-outline-color": "#f8fafc",
                "background-opacity": 0.95,
                "border-color": "#a5b4fc",
                "border-width": "mapData(weight, 0, 40, 2, 6)",
              },
            },
            {
              selector: "edge",
              style: {
                "curve-style": "unbundled-bezier",
                "line-color": "rgba(148, 163, 184, 0.55)",
                "target-arrow-color": "rgba(148, 163, 184, 0.55)",
                width: "mapData(weight, 0, 30, 1, 9)",
                opacity: 0.65,
              },
            },
          ],
        });

        cy.on("tap", "node", (evt) => {
          const node = evt.target.data();
          showNodeDetails(node.id);
        });
      }

      function populateSelect(select, options, preferred) {
        select.innerHTML = "";
        options.forEach((option) => {
          const opt = document.createElement("option");
          opt.value = option.code;
          opt.textContent = option.label;
          select.appendChild(opt);
        });
        if (preferred && options.some((opt) => opt.code === preferred)) {
          select.value = preferred;
        }
      }

      function tokenize(text) {
        return (text.toLowerCase().match(/[a-z0-9'\-]+/g) || []).filter(
          (token) => {
            return token.length > 2 && !STOPWORDS.has(token);
          }
        );
      }

      function decayGraph(factor = 0.995) {
        for (const node of graph.nodes.values()) {
          node.weight *= factor;
          if (node.weight < 0.05) {
            graph.nodes.delete(node.id);
          }
        }
        for (const edge of graph.edges.values()) {
          edge.weight *= factor;
          if (edge.weight < 0.05) {
            graph.edges.delete(edge.id);
          }
        }
      }

      function addNode(id, label, increment) {
        if (!graph.nodes.has(id)) {
          graph.nodes.set(id, { id, label, weight: 0 });
        }
        graph.nodes.get(id).weight += increment;
      }

      function addEdge(a, b, increment) {
        const id = a < b ? `${a}|${b}` : `${b}|${a}`;
        if (!graph.edges.has(id)) {
          graph.edges.set(id, { id, source: a, target: b, weight: 0 });
        }
        graph.edges.get(id).weight += increment;
      }

      async function processTranscript(text, isFinal) {
        if (!text.trim()) return;

        // Simple token-based processing for immediate feedback
        const tokens = tokenize(text);
        if (tokens.length) {
          const weight = isFinal ? 1 : 0.4;
          for (const token of tokens) {
            addNode(token, token, weight);
          }
          for (let i = 0; i < tokens.length - 1; i++) {
            addEdge(tokens[i], tokens[i + 1], weight * 0.8);
          }
          decayGraph(0.997);
          updateMindmap();
        }

        if (isFinal) {
          const timestamp = new Date();
          segments.push({
            id: crypto.randomUUID(),
            text,
            tokens,
            createdAt: timestamp.toISOString(),
          });
          recentTranscripts.push(text);
          if (recentTranscripts.length > maxTranscriptBuffer) {
            recentTranscripts.shift();
          }
          appendSegment(text, timestamp);

          // Trigger AI analysis
          await analyzeWithGroq();
        }
      }

      async function analyzeWithGroq() {
        if (aiAnalysisPending) return;

        const transcriptsToAnalyze = recentTranscripts.slice(-3).join(" ");
        if (transcriptsToAnalyze.length < 50) return; // Wait for more content

        aiAnalysisPending = true;
        updateAIStatus("Analyzing...", false);

        try {
          const model = modelSelect.value;

          // Call backend API instead of Groq directly
          const response = await fetch("/api/analyze", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              transcripts: transcriptsToAnalyze,
              model: model,
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(
              errorData.message || `API error: ${response.status}`
            );
          }

          const data = await response.json();
          const analysis = data.analysis;

          if (analysis) {
            processAIAnalysis(analysis);
            updateAIStatus("Analysis complete", true);
            displayAISummary(analysis);
          }
        } catch (error) {
          console.error("AI Analysis error:", error);
          updateAIStatus("Analysis failed", false, error.message);
        } finally {
          aiAnalysisPending = false;
        }
      }

      function processAIAnalysis(analysis) {
        // Add concepts as nodes
        if (analysis.concepts) {
          analysis.concepts.forEach((concept) => {
            const normalizedConcept = concept.toLowerCase().trim();
            addNode(normalizedConcept, concept, 5); // Higher weight for AI-extracted concepts
          });
        }

        // Add relationships as edges
        if (analysis.relationships) {
          analysis.relationships.forEach((rel) => {
            const source = rel.source?.toLowerCase().trim();
            const target = rel.target?.toLowerCase().trim();
            const strength = Math.min(rel.strength || 1, 10);
            if (source && target) {
              addEdge(source, target, strength);
            }
          });
        }

        updateMindmap();
      }

      function displayAISummary(analysis) {
        let summaryHTML = "";

        if (analysis.summary) {
          summaryHTML += `<p><strong>Summary:</strong> ${analysis.summary}</p>`;
        }

        if (analysis.themes && analysis.themes.length > 0) {
          summaryHTML += `<p><strong>Themes:</strong> ${analysis.themes.join(
            ", "
          )}</p>`;
        }

        if (analysis.concepts && analysis.concepts.length > 0) {
          summaryHTML += `<p><strong>Key Concepts:</strong> ${analysis.concepts
            .slice(0, 10)
            .join(", ")}</p>`;
        }

        aiOutput.innerHTML = summaryHTML || "<p>Analysis complete.</p>";
      }

      function updateAIStatus(message, success = false, error = null) {
        aiStatus.innerHTML = "";
        const pill = document.createElement("div");
        pill.className = success
          ? "metric-pill success"
          : error
          ? "metric-pill danger"
          : "metric-pill";
        pill.textContent = message;
        aiStatus.appendChild(pill);

        if (error) {
          const errorText = document.createElement("small");
          errorText.textContent = error;
          errorText.style.color = "#b91c1c";
          aiStatus.appendChild(errorText);
        }
      }

      function appendSegment(text, timestamp) {
        const wrapper = document.createElement("div");
        wrapper.className = "segment";
        const timeEl = document.createElement("time");
        timeEl.textContent = new Intl.DateTimeFormat([], {
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
        }).format(new Date(timestamp));
        const textEl = document.createElement("p");
        textEl.textContent = text;
        wrapper.appendChild(timeEl);
        wrapper.appendChild(textEl);
        transcriptLog.prepend(wrapper);
      }

      function updateMindmap() {
        if (!cy) return;
        const maxNodes = 60;
        const nodes = Array.from(graph.nodes.values())
          .sort((a, b) => b.weight - a.weight)
          .slice(0, maxNodes);
        const nodeSet = new Set(nodes.map((n) => n.id));
        const edges = Array.from(graph.edges.values()).filter(
          (e) => nodeSet.has(e.source) && nodeSet.has(e.target)
        );

        cy.startBatch();
        cy.elements().remove();
        cy.add(nodes.map((n) => ({ data: n })));
        cy.add(edges.map((e) => ({ data: e })));
        cy.layout({
          name: "cose",
          animate: true,
          randomize: false,
          padding: 40,
        }).run();
        cy.endBatch();
      }

      function showNodeDetails(nodeId) {
        const relatedSegments = segments
          .filter((seg) => seg.tokens.includes(nodeId))
          .slice(-6)
          .reverse();

        detailsPanel.innerHTML = "";
        if (!relatedSegments.length) {
          detailsPanel.innerHTML =
            "<p>No captured quotes linked to this topic yet.</p>";
          return;
        }

        for (const seg of relatedSegments) {
          const item = document.createElement("div");
          item.className = "detail-item";
          const time = document.createElement("time");
          time.textContent = new Intl.DateTimeFormat([], {
            hour: "numeric",
            minute: "2-digit",
            second: "2-digit",
          }).format(new Date(seg.createdAt));
          const text = document.createElement("p");
          text.textContent = seg.text;
          item.appendChild(time);
          item.appendChild(text);
          detailsPanel.appendChild(item);
        }
      }

      function resetSession() {
        graph.nodes.clear();
        graph.edges.clear();
        segments.length = 0;
        recentTranscripts.length = 0;
        transcriptLog.innerHTML = "";
        detailsPanel.innerHTML =
          "<p>Select a node in the mindmap to see the most recent notes and quotes linked to it.</p>";
        liveTranscript.textContent = "Waiting for speech…";
        aiOutput.textContent = "AI insights will appear here...";
        updateAIStatus("Ready", false);
        updateMindmap();
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        exportBtn.disabled = true;
        pauseBtn.textContent = "Pause";
        isCapturing = false;
        isPaused = false;
        allowAutoRestart = false;
        setStatus("Idle • microphone permissions required", false);
      }

      function exportSession() {
        const payload = {
          exportedAt: new Date().toISOString(),
          segments,
          nodes: Array.from(graph.nodes.values()),
          edges: Array.from(graph.edges.values()),
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `mindmap-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setStatus(text, active) {
        statusText.textContent = text;
        statusIndicator.classList.toggle("active", active);
      }

      function setupRecognition() {
        if (!SpeechRecognition) {
          setStatus(
            "Speech recognition unavailable in this browser. Please use Chrome-based browsers.",
            false
          );
          startBtn.disabled = true;
          return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang =
          sourceLangSelect.value === "auto"
            ? navigator.language || "en-US"
            : sourceLangSelect.value;

        recognition.onresult = (event) => {
          let interimTranscript = "";
          for (let i = event.resultIndex; i < event.results.length; ++i) {
            const result = event.results[i];
            const transcript = result[0].transcript.trim();
            if (!transcript) continue;
            if (result.isFinal) {
              liveTranscript.textContent = "✔ " + transcript;
              processTranscript(transcript, true);
            } else {
              interimTranscript = transcript;
              liveTranscript.textContent = "… " + transcript;
              processTranscript(transcript, false);
            }
          }
          if (
            !interimTranscript &&
            !event.results[event.results.length - 1]?.isFinal
          ) {
            liveTranscript.textContent = "Listening…";
          }
        };

        recognition.onerror = (event) => {
          console.error("Speech recognition error", event.error);
          setStatus(`Error: ${event.error}`, false);
          startBtn.disabled = false;
          pauseBtn.disabled = true;
          stopBtn.disabled = false;
          allowAutoRestart = false;
          isCapturing = false;
        };

        recognition.onend = () => {
          if (isCapturing && !isPaused && allowAutoRestart) {
            setStatus("Restarting capture…", true);
            recognition.start();
          }
        };
      }

      startBtn.addEventListener("click", () => {
        if (!recognition) return;
        recognition.lang =
          sourceLangSelect.value === "auto"
            ? navigator.language || "en-US"
            : sourceLangSelect.value;
        allowAutoRestart = true;
        recognition.start();
        isCapturing = true;
        isPaused = false;
        pauseBtn.textContent = "Pause";
        setStatus(
          "Listening… speak naturally for live AI-powered mindmap.",
          true
        );
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        exportBtn.disabled = false;
      });

      pauseBtn.addEventListener("click", () => {
        if (!recognition) return;
        if (!isPaused) {
          allowAutoRestart = false;
          recognition.stop();
          isPaused = true;
          pauseBtn.textContent = "Resume";
          setStatus("Paused • resume when ready", false);
        } else {
          recognition.lang =
            sourceLangSelect.value === "auto"
              ? navigator.language || "en-US"
              : sourceLangSelect.value;
          allowAutoRestart = true;
          recognition.start();
          isPaused = false;
          pauseBtn.textContent = "Pause";
          setStatus(
            "Listening… speak naturally for live AI-powered mindmap.",
            true
          );
        }
      });

      stopBtn.addEventListener("click", () => {
        if (recognition) {
          allowAutoRestart = false;
          recognition.stop();
        }
        resetSession();
      });

      exportBtn.addEventListener("click", exportSession);

      noteInput.addEventListener("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          const note = noteInput.value.trim();
          if (note) {
            processTranscript(note, true);
            noteInput.value = "";
          }
        }
      });

      sourceLangSelect.addEventListener("change", () => {
        const lang = sourceLangSelect.value;
        if (recognition) {
          const wasActive = isCapturing && !isPaused;
          if (wasActive) {
            allowAutoRestart = false;
            recognition.stop();
          }
          recognition.lang =
            lang === "auto" ? navigator.language || "en-US" : lang;
          if (wasActive) {
            setTimeout(() => {
              allowAutoRestart = true;
              recognition.start();
            }, 250);
          }
        }
        setStatus(
          `Source language set to ${sourceLangSelect.selectedOptions[0].textContent}.`,
          isCapturing && !isPaused
        );
      });

      function initialiseControls() {
        const preferredSource =
          navigator.language &&
          LANGUAGE_OPTIONS.some((l) => l.code === navigator.language)
            ? navigator.language
            : "en-US";
        populateSelect(sourceLangSelect, LANGUAGE_OPTIONS, preferredSource);
      }

      initCytoscape();
      initialiseControls();
      setupRecognition();
      resetSession();
    </script>
  </body>
</html>

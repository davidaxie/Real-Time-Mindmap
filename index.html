<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Talkstorm - AI Mindmap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        color-scheme: dark;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        /* Dark theme color palette */
        --bg-main: #1e1b2e;
        --bg-soft: #27223c;
        --bg-panel: #2d2748;
        --text-primary: #e2e8f0;
        --text-secondary: #a0aec0;
        --dark-blue: #3b82f6;
        --dark-purple: #8b5cf6;
        --dark-pink: #ec4899;
        --dark-cyan: #06b6d4;
        --border: #4a5568;
        --shadow: rgba(0, 0, 0, 0.3);
        --shadow-soft: rgba(0, 0, 0, 0.2);
      }

      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        background: linear-gradient(
          135deg,
          #1e1b2e 0%,
          #27223c 50%,
          #1e1b2e 100%
        );
        color: var(--text-primary);
      }

      /* Top bar with menu button */
      .top-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: rgba(30, 27, 46, 0.9);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding: 0 20px;
        z-index: 1000;
      }

      .menu-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          var(--dark-blue),
          var(--dark-purple)
        );
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 20px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 12px var(--shadow);
      }

      .menu-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
      }

      /* Main layout: mindmap on left, controls on right */
      .app-container {
        display: flex;
        height: 100vh;
        padding-top: 60px;
      }

      /* Left side: Mindmap */
      .mindmap-panel {
        flex: 1;
        position: relative;
        background: var(--bg-main);
        border-right: 1px solid var(--border);
        overflow: hidden;
      }

      #mindmap {
        width: 100%;
        height: 100%;
        background: var(--bg-main);
      }

      /* Style MindElixir nodes with random bright colors */
      #mindmap .me-node {
        background: white !important;
        border-radius: 8px !important;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
        padding: 4px 8px !important;
        border: 2px solid !important;
      }

      #mindmap .me-node circle {
        fill: white !important;
      }

      /* Dark text for all nodes */
      #mindmap text,
      #mindmap tspan {
        fill: #1e293b !important;
        font-weight: 500 !important;
      }

      /* Path colors for dark theme */
      #mindmap path {
        stroke: var(--dark-cyan) !important;
        stroke-width: 2px !important;
        stroke-opacity: 0.6 !important;
      }

      /* Floating Apple-style input bar at bottom */
      .floating-input {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 600px;
        height: 56px;
        background: rgba(45, 39, 72, 0.95);
        backdrop-filter: blur(30px);
        border-radius: 28px;
        border: 1px solid var(--border);
        box-shadow: 0 8px 32px var(--shadow-soft);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 100;
      }

      .floating-input input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        font-size: 16px;
        color: var(--text-primary);
        padding: 0 10px;
      }

      .floating-input input::placeholder {
        color: var(--text-secondary);
      }

      /* Right side: Controls panel */
      .controls-panel {
        width: 380px;
        background: var(--bg-panel);
        border-left: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }

      .controls-header {
        padding: 20px;
        border-bottom: 1px solid var(--border);
      }

      .controls-header h2 {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 16px;
      }

      /* Pastel control buttons */
      .control-buttons {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }

      .control-btn {
        flex: 1;
        height: 40px;
        border-radius: 20px;
        border: none;
        font-weight: 500;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .control-btn.start {
        background: linear-gradient(135deg, var(--dark-cyan), #0891b2);
        color: white;
      }

      .control-btn.pause {
        background: linear-gradient(135deg, var(--dark-purple), #7c3aed);
        color: white;
      }

      .control-btn.stop {
        background: linear-gradient(135deg, var(--dark-pink), #db2777);
        color: white;
      }

      .control-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px var(--shadow);
      }

      .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Context button */
      .context-btn {
        width: 100%;
        height: 40px;
        background: linear-gradient(135deg, var(--dark-blue), #2563eb);
        color: white;
        border: none;
        border-radius: 20px;
        font-weight: 500;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-bottom: 16px;
        transition: all 0.3s ease;
      }

      .context-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }

      /* Combined transcript and AI section */
      .analysis-section {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
      }

      .section-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 12px;
      }

      .live-transcript-box {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 16px;
        min-height: 120px;
        margin-bottom: 20px;
        border: 1px solid var(--border);
      }

      #live-transcript {
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-primary);
        min-height: 80px;
      }

      .ai-analysis-box {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 16px;
        border: 1px solid var(--border);
      }

      #ai-output {
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-primary);
      }

      /* Hidden file inputs */
      #context-input,
      #file-input {
        display: none;
      }

      /* Scrollbar styling */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-soft);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--dark-blue);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--dark-purple);
      }

      /* Mobile responsive */
      @media (max-width: 768px) {
        .app-container {
          flex-direction: column;
        }

        .controls-panel {
          width: 100%;
          max-height: 50vh;
        }

        .mindmap-panel {
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
      }
    </style>
    <script src="./node_modules/mind-elixir/dist/MindElixir.iife.js"></script>
    <link
      rel="stylesheet"
      href="./node_modules/mind-elixir/dist/MindElixir.css"
    />
  </head>
  <body>
    <!-- Top bar with settings -->
    <div class="top-bar">
      <button class="menu-btn" id="menu-btn" title="Settings">⚙️</button>
    </div>

    <!-- Main app container -->
    <div class="app-container">
      <!-- Left: Mindmap -->
      <div class="mindmap-panel">
        <div id="mindmap"></div>

        <!-- Floating Apple-style input bar -->
        <div class="floating-input">
          <input
            type="text"
            id="floating-note-input"
            placeholder="Add a note or context..."
            autocomplete="off"
          />
        </div>
      </div>

      <!-- Right: Controls -->
      <div class="controls-panel">
        <div class="controls-header">
          <h2>Talkstorm</h2>

          <!-- Control buttons -->
          <div class="control-buttons">
            <button class="control-btn start" id="start-btn">▶ Start</button>
            <button class="control-btn pause" id="pause-btn" disabled>
              ⏸ Pause
            </button>
            <button class="control-btn stop" id="stop-btn" disabled>
              ⏹ Stop
            </button>
          </div>

          <!-- Context upload button -->
          <button class="context-btn" id="context-btn">
            📎 Upload Context
          </button>
          <input type="file" id="context-input" accept=".txt,.pdf,.doc,.docx" />

          <!-- Load JSON button (hidden by default, can be added to menu) -->
          <input
            type="file"
            id="file-input"
            accept=".json"
            style="display: none"
          />
        </div>

        <!-- Combined analysis section -->
        <div class="analysis-section">
          <div class="live-transcript-box">
            <div class="section-title">Live Transcript</div>
            <div id="live-transcript">Waiting for speech…</div>
          </div>

          <div class="ai-analysis-box">
            <div class="section-title">AI Analysis</div>
            <div id="ai-output">AI insights will appear here...</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;

      const LANGUAGE_OPTIONS = [
        { code: "auto", label: "Auto detect" },
        { code: "en-US", label: "English (United States)" },
        { code: "en-GB", label: "English (United Kingdom)" },
        { code: "es-ES", label: "Spanish" },
        { code: "fr-FR", label: "French" },
        { code: "de-DE", label: "German" },
        { code: "pt-BR", label: "Portuguese (Brazil)" },
        { code: "it-IT", label: "Italian" },
        { code: "hi-IN", label: "Hindi" },
        { code: "ja-JP", label: "Japanese" },
        { code: "zh-CN", label: "Chinese (Mandarin)" },
      ];

      const graph = {
        nodes: new Map(),
        edges: new Map(),
      };

      // Global API call queue variables
      let apiCallQueue = [];
      let isProcessingQueue = false;

      // Global API call queue to serialize requests
      async function queueAPICall(apiFunction) {
        return new Promise((resolve, reject) => {
          apiCallQueue.push({ apiFunction, resolve, reject });
          processQueue();
        });
      }

      // Track consecutive 429 errors for exponential backoff
      let consecutive429Errors = 0;

      async function processQueue() {
        if (isProcessingQueue || apiCallQueue.length === 0) return;

        isProcessingQueue = true;

        while (apiCallQueue.length > 0) {
          const { apiFunction, resolve, reject } = apiCallQueue.shift();

          try {
            const result = await apiFunction();
            resolve(result);

            // Reset 429 counter on success
            if (consecutive429Errors > 0) {
              consecutive429Errors = 0;
            }

            // Wait between API calls to respect rate limits
            const now = Date.now();
            const timeSinceLastCall = now - lastAICall;
            let waitTime = 0;

            if (timeSinceLastCall < AI_RATE_LIMIT_MS) {
              waitTime = AI_RATE_LIMIT_MS - timeSinceLastCall;
            }

            // Exponential backoff if we've been rate limited
            if (consecutive429Errors > 0) {
              waitTime = Math.max(
                waitTime,
                1000 * Math.min(consecutive429Errors * 2, 10)
              );
              console.log(
                `⏸️ Backing off for ${waitTime}ms due to rate limiting`
              );
            }

            if (waitTime > 0) {
              await new Promise((r) => setTimeout(r, waitTime));
            }
            lastAICall = Date.now();
          } catch (error) {
            // Track 429 errors for exponential backoff
            if (error.message && error.message.includes("429")) {
              consecutive429Errors++;
              console.warn(
                `⚠️ Rate limited (${consecutive429Errors} consecutive). Backing off...`
              );
            }
            reject(error);
          }
        }

        isProcessingQueue = false;
      }

      const segments = [];
      const recentTranscripts = [];
      const maxTranscriptBuffer = 10;
      let recognition;
      let recognitionInitialized = false;
      let isPaused = false;
      let isCapturing = false;
      let allowAutoRestart = false;
      let aiAnalysisPending = false;
      let aiAnalysisQueue = [];
      let lastAICall = 0;
      const AI_RATE_LIMIT_MS = 3000; // Wait 3 seconds between AI calls

      // For continuous speech without pauses
      let lastTranscriptTime = Date.now();
      let lastFinalTime = Date.now();
      const CONTINUOUS_SPEECH_TIMEOUT = 5000; // 5 seconds before forcing finalization

      let mind = null; // Mind Elixir instance

      // Get DOM elements
      const startBtn = document.getElementById("start-btn");
      const pauseBtn = document.getElementById("pause-btn");
      const stopBtn = document.getElementById("stop-btn");
      const contextBtn = document.getElementById("context-btn");
      const contextInput = document.getElementById("context-input");
      const fileInput = document.getElementById("file-input");
      const liveTranscript = document.getElementById("live-transcript");
      const aiOutput = document.getElementById("ai-output");
      const floatingNoteInput = document.getElementById("floating-note-input");
      const menuBtn = document.getElementById("menu-btn");

      // Generate random bright colors for nodes
      function getRandomBrightColor() {
        const brightColors = [
          "#FF6B9D", // Bright pink
          "#4ECDC4", // Bright turquoise
          "#FFE66D", // Bright yellow
          "#A8E6CF", // Bright mint
          "#FFB4D8", // Bright rose
          "#B4E4FF", // Bright sky blue
          "#DDA0DD", // Lavender
          "#FFD93D", // Golden yellow
          "#6BCB77", // Green
          "#FF8787", // Coral
          "#9B59B6", // Purple
          "#3498DB", // Blue
          "#E74C3C", // Red
          "#1ABC9C", // Teal
          "#F39C12", // Orange
        ];
        return brightColors[Math.floor(Math.random() * brightColors.length)];
      }

      function applyNodeColors() {
        // Apply colors after a short delay to ensure nodes are rendered
        setTimeout(() => {
          const nodes = document.querySelectorAll("#mindmap .me-node");
          nodes.forEach((node, index) => {
            const color =
              index === 0
                ? "linear-gradient(135deg, #3b82f6, #8b5cf6)"
                : getRandomBrightColor();
            node.style.background = color;
            node.style.borderColor = color;
          });
        }, 100);
      }

      function initMindMap() {
        try {
          if (typeof MindElixir === "undefined") {
            console.error("❌ Mind Elixir not loaded");
            return;
          }

          console.log("🔵 MindElixir found:", typeof MindElixir);

          mind = new MindElixir({
            el: "#mindmap",
            direction: MindElixir.SIDE,
            locale: "en",
            contextMenu: false,
            toolBar: false,
            keypress: false,
            draggable: false,
            editable: false,
            primaryNodeBackground: "linear-gradient(135deg, #3b82f6, #8b5cf6)",
            primaryNodeColor: "#e2e8f0",
          });

          const initialData = {
            topic: "Talkstorm",
            id: "talkstorm",
            expanded: true,
          };

          mind.init(initialData);
          applyNodeColors();
          console.log("✅ Mind map initialized");
        } catch (error) {
          console.error("❌ Error initializing mind map:", error);
        }
      }

      // Convert graph nodes to Mind Elixir format - Hub & Spoke Layout
      function convertToMindElixirFormat(sortedNodes) {
        const n = sortedNodes.length;

        const rootNode = {
          topic: "Talkstorm",
          id: "talkstorm",
          expanded: true,
        };

        if (n === 0) {
          return rootNode;
        }

        if (n <= 5) {
          rootNode.children = sortedNodes.map((node) => ({
            topic: node.label,
            id: node.id,
            expanded: true,
          }));
          return rootNode;
        }

        const bubbleSize = Math.max(1, Math.floor(n * 0.35));
        const bubbleNodes = sortedNodes.slice(0, bubbleSize);
        const branchNodes = sortedNodes.slice(bubbleSize);

        console.log(
          `📊 Talkstorm Layout: ${n} nodes | Bubble: ${bubbleNodes.length} | Branches: ${branchNodes.length}`
        );

        const bubbleChildren = bubbleNodes.map((bubbleNode) => {
          const childrenPerBubble = Math.floor(
            branchNodes.length / bubbleNodes.length
          );
          const startIdx = bubbleNodes.indexOf(bubbleNode) * childrenPerBubble;
          const endIdx = startIdx + childrenPerBubble;
          const nodeChildren = branchNodes.slice(startIdx, endIdx);

          return {
            topic: bubbleNode.label,
            id: bubbleNode.id,
            expanded: true,
            children: nodeChildren.map((node) => ({
              topic: node.label,
              id: node.id,
              expanded: true,
            })),
          };
        });

        rootNode.children = bubbleChildren;
        return rootNode;
      }

      function populateSelect(select, options, preferred) {
        select.innerHTML = "";
        options.forEach((option) => {
          const opt = document.createElement("option");
          opt.value = option.code;
          opt.textContent = option.label;
          select.appendChild(opt);
        });
        if (preferred && options.some((opt) => opt.code === preferred)) {
          select.value = preferred;
        }
      }

      function tokenize(text) {
        return (text.toLowerCase().match(/[a-z0-9'\-]+/g) || []).filter(
          (token) => token.length > 2
        );
      }

      function decayGraph(factor = 0.995) {
        for (const node of graph.nodes.values()) {
          node.weight *= factor;
          if (node.weight < 0.05) {
            graph.nodes.delete(node.id);
          }
        }
        for (const edge of graph.edges.values()) {
          edge.weight *= factor;
          if (edge.weight < 0.05) {
            graph.edges.delete(edge.id);
          }
        }
      }

      function addNode(id, label, increment) {
        if (!graph.nodes.has(id)) {
          graph.nodes.set(id, { id, label, weight: 0 });
        }
        graph.nodes.get(id).weight += increment;
      }

      function findExistingNode(label) {
        const normalizedLabel = label.toLowerCase();
        for (const [nodeId, node] of graph.nodes.entries()) {
          if (node.label.toLowerCase() === normalizedLabel) {
            return node;
          }
        }
        return null;
      }

      function addEdge(a, b, increment) {
        const safeIncrement =
          increment && !isNaN(increment) ? Number(increment) : 1;
        const id = a < b ? `${a}|${b}` : `${b}|${a}`;
        if (!graph.edges.has(id)) {
          graph.edges.set(id, {
            id,
            source: a,
            target: b,
            weight: safeIncrement,
          });
        } else {
          graph.edges.get(id).weight += safeIncrement;
        }
      }

      const recentTextHashes = new Map();
      function hashText(text) {
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
          const char = text.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return hash;
      }

      function isDuplicate(text, withinMs = 1000) {
        const hash = hashText(text.toLowerCase());
        const now = Date.now();

        if (recentTextHashes.has(hash)) {
          const seenAt = recentTextHashes.get(hash);
          if (now - seenAt < withinMs) {
            return true;
          }
        }

        recentTextHashes.set(hash, now);

        for (const [h, time] of recentTextHashes.entries()) {
          if (now - time > withinMs * 10) {
            recentTextHashes.delete(h);
          }
        }

        return false;
      }

      async function processTranscript(text, isFinal) {
        if (!text.trim()) return;

        const now = Date.now();
        lastTranscriptTime = now;

        if (isFinal) {
          lastFinalTime = now;
        }

        const timeSinceLastFinal = now - lastFinalTime;
        const isForcedFinal =
          !isFinal &&
          timeSinceLastFinal > CONTINUOUS_SPEECH_TIMEOUT &&
          text.length > 30;

        const shouldProcessAsFinal = isFinal || isForcedFinal;

        if (shouldProcessAsFinal && isDuplicate(text, 1000)) {
          return;
        }

        if (shouldProcessAsFinal && text.length > 20) {
          if (isForcedFinal) {
            console.log(
              `🔵 Forcing finalization after ${Math.round(
                timeSinceLastFinal / 1000
              )}s of continuous speech`
            );
          }
          await processWithAI(text);
          lastFinalTime = now;
        } else if (text.length > 20) {
          return;
        }

        if (shouldProcessAsFinal) {
          const timestamp = new Date();
          segments.push({
            id: crypto.randomUUID(),
            text,
            tokens: tokenize(text),
            createdAt: timestamp.toISOString(),
          });
          recentTranscripts.push(text);
          if (recentTranscripts.length > maxTranscriptBuffer) {
            recentTranscripts.shift();
          }
          appendSegment(text, timestamp);

          await analyzeWithGroq();
        }
      }

      async function processWithAI(sentence) {
        try {
          updateAIStatus("Extracting theme...", false);

          const { theme } = await queueAPICall(async () => {
            const themeResponse = await fetch(
              "http://localhost:3001/api/extract-theme",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  sentence,
                  model: "llama-3.1-8b-instant",
                }),
              }
            );

            if (!themeResponse.ok) throw new Error("Theme extraction failed");
            const data = await themeResponse.json();
            return data;
          });

          if (!theme) return;

          // Filter out conversational AI responses
          const conversationalPatterns = [
            /i['\u2019]d?\s+(be\s+)?happy/i,
            /i can\s+/i,
            /i would\s+/i,
            /id happy/i,
            /create.*mind.*map.*real/i,
            /^i\s+/i,
            /^i'd\s+/i,
            /^i'am\s+/i,
            /can help/i,
            /would you like/i,
            /let me/i,
          ];

          const isConversational = conversationalPatterns.some((pattern) =>
            pattern.test(theme)
          );

          if (isConversational || theme.length > 50) {
            console.warn(`🚫 Rejected conversational theme: "${theme}"`);
            const words = sentence
              .split(/\s+/)
              .filter((w) => w.length > 2)
              .slice(0, 3);
            theme = words.join(" ") || sentence.substring(0, 30);
            console.log(`✅ Using fallback theme: "${theme}"`);
          }

          const allExistingNodes = Array.from(graph.nodes.values());
          const MAX_NODES_TO_CONSIDER = 15;
          const topExistingNodes = allExistingNodes
            .sort((a, b) => b.weight - a.weight)
            .slice(0, MAX_NODES_TO_CONSIDER);
          const existingNodeLabels = topExistingNodes.map((n) => n.label);

          updateAIStatus("Finding connections...", false);
          const { connections: connectionsData } = await queueAPICall(
            async () => {
              const connectionsResponse = await fetch(
                "http://localhost:3001/api/find-connections",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    newNode: theme,
                    existingNodes: existingNodeLabels,
                    model: "llama-3.1-8b-instant",
                  }),
                }
              );

              let connections = [];
              if (connectionsResponse.ok) {
                const data = await connectionsResponse.json();
                connections = data.connections || [];
              }
              return { connections };
            }
          );

          let connections = connectionsData || [];

          if (connections.length === 0 && allExistingNodes.length > 0) {
            const highestWeighted = allExistingNodes.sort(
              (a, b) => b.weight - a.weight
            )[0];
            connections.push({
              node: highestWeighted.label,
              strength: 0.3,
              reason: "fallback",
            });
          }

          const weightIncrement = 3;
          const validatedConnections = [];

          for (const conn of connections) {
            const nodeId = conn.node.toLowerCase();
            const strength = Number(conn.strength);
            const validStrength =
              !isNaN(strength) && strength > 0 ? strength : 0.5;

            if (graph.nodes.has(nodeId)) {
              const node = graph.nodes.get(nodeId);
              node.weight += weightIncrement * validStrength;
              node.weight = Math.min(node.weight, 100);

              validatedConnections.push({
                node: conn.node,
                strength: validStrength,
              });
            }
          }

          const normalizedThemeId = theme.toLowerCase().trim();
          let existingNode;
          if (graph.nodes.has(normalizedThemeId)) {
            existingNode = graph.nodes.get(normalizedThemeId);
          } else {
            existingNode = findExistingNode(theme);
          }

          let nodeWeight;
          if (existingNode) {
            existingNode.weight += weightIncrement + 5;
            existingNode.weight = Math.min(existingNode.weight, 100);
            nodeWeight = existingNode.weight;
          } else {
            const baseWeight = 5;
            const connectionBonus = connections.length * 2;
            nodeWeight = baseWeight + connectionBonus;
            addNode(normalizedThemeId, theme, nodeWeight);
          }

          for (const conn of validatedConnections) {
            addEdge(
              normalizedThemeId,
              conn.node.toLowerCase(),
              conn.strength * 10
            );
          }

          decayGraph(0.995);
          updateMindmap();

          const weightChanges = [];
          for (const conn of validatedConnections) {
            weightChanges.push(
              `${conn.node}+${Math.round(weightIncrement * conn.strength)}`
            );
          }

          updateAIStatus(
            `Added: "${theme}" (weight: ${nodeWeight})${
              weightChanges.length > 0
                ? ` | Boosted: ${weightChanges.join(", ")}`
                : ""
            }`,
            true
          );
        } catch (error) {
          console.error("AI processing error:", error);
          if (error.message.includes("429")) {
            updateAIStatus(
              "Rate limited - slowing down...",
              false,
              "Too many requests. Wait a moment."
            );
          } else {
            updateAIStatus("AI processing failed", false, error.message);
          }
        }
      }

      async function analyzeWithGroq() {
        if (aiAnalysisPending) return;

        const transcriptsToAnalyze = recentTranscripts.slice(-3).join(" ");
        if (transcriptsToAnalyze.length < 50) return;

        aiAnalysisPending = true;
        updateAIStatus("Analyzing...", false);

        try {
          const data = await queueAPICall(async () => {
            const response = await fetch("http://localhost:3001/api/analyze", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                transcripts: transcriptsToAnalyze,
                model: "llama-3.1-8b-instant",
              }),
            });

            if (!response.ok) {
              const errorData = await response
                .json()
                .catch(() => ({ error: "Unknown error" }));

              if (response.status === 429) {
                updateAIStatus(
                  "Rate limited - slowing down...",
                  false,
                  "Too many requests. Wait a moment."
                );
                throw new Error("Rate limited");
              }

              throw new Error(
                errorData.message ||
                  errorData.error ||
                  `API error: ${response.status}`
              );
            }

            return await response.json();
          });

          const analysis = data.analysis;

          if (analysis) {
            processAIAnalysis(analysis);
            updateAIStatus("Analysis complete", true);
            displayAISummary(analysis);
          }
        } catch (error) {
          console.error("AI Analysis error:", error);
          if (
            !error.message.includes("429") &&
            !error.message.includes("Rate limited")
          ) {
            updateAIStatus("Analysis failed", false, error.message);
          }
        } finally {
          aiAnalysisPending = false;
        }
      }

      function processAIAnalysis(analysis) {
        if (analysis.concepts) {
          analysis.concepts.forEach((concept) => {
            const normalizedConcept = concept.toLowerCase().trim();
            addNode(normalizedConcept, concept, 5);
          });
        }

        if (analysis.relationships) {
          analysis.relationships.forEach((rel) => {
            const source = rel.source?.toLowerCase().trim();
            const target = rel.target?.toLowerCase().trim();
            let strength = Number(rel.strength);
            if (isNaN(strength) || strength <= 0) strength = 1;
            strength = Math.min(strength, 10);

            if (source && target && source !== target) {
              addEdge(source, target, strength);
            }
          });
        }

        updateMindmap();
      }

      function displayAISummary(analysis) {
        let summaryHTML = "";

        if (analysis.summary) {
          summaryHTML += `<p><strong>Summary:</strong> ${analysis.summary}</p>`;
        }

        if (analysis.themes && analysis.themes.length > 0) {
          summaryHTML += `<p><strong>Themes:</strong> ${analysis.themes.join(
            ", "
          )}</p>`;
        }

        if (analysis.concepts && analysis.concepts.length > 0) {
          summaryHTML += `<p><strong>Key Concepts:</strong> ${analysis.concepts
            .slice(0, 10)
            .join(", ")}</p>`;
        }

        aiOutput.innerHTML = summaryHTML || "<p>Analysis complete.</p>";
      }

      function updateAIStatus(message, success = false, error = null) {
        aiOutput.innerHTML = `<p class="${
          success ? "success" : ""
        }">${message}${
          error
            ? '<br><small style="color: #b91c1c;">' + error + "</small>"
            : ""
        }</p>`;
      }

      function appendSegment(text, timestamp) {
        // Update live transcript
        liveTranscript.textContent = text;
        console.log("📋 Transcript updated:", text);
      }

      function updateMindmap() {
        if (!mind) {
          console.warn("⚠️ Mind map not available yet");
          return;
        }
        const maxVisibleNodes = 20;

        const sortedNodes = Array.from(graph.nodes.values()).sort(
          (a, b) => b.weight - a.weight
        );
        const visibleNodes = sortedNodes.slice(0, maxVisibleNodes);
        const mindData = convertToMindElixirFormat(visibleNodes);
        mind.init({ nodeData: mindData });

        // Reapply colors after update
        applyNodeColors();
      }

      function resetSession() {
        graph.nodes.clear();
        graph.edges.clear();
        segments.length = 0;
        recentTranscripts.length = 0;
        liveTranscript.textContent = "Waiting for speech…";
        aiOutput.textContent = "AI insights will appear here...";
        updateMindmap();

        startBtn.disabled = !recognitionInitialized;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        isCapturing = false;
        isPaused = false;
        allowAutoRestart = false;
      }

      function setStatus(text, active) {
        aiOutput.textContent = text;
      }

      function setupRecognition() {
        console.log("=== SETUP RECOGNITION START ===");

        try {
          if (!SpeechRecognition) {
            console.error("❌ Speech recognition not available");
            setStatus(
              "Speech recognition unavailable. Please use Chrome/Edge.",
              false
            );
            startBtn.disabled = true;
            recognitionInitialized = false;
            return;
          }

          recognition = new SpeechRecognition();
          recognitionInitialized = true;
          recognition.continuous = true;
          recognition.interimResults = true;
          recognition.lang = navigator.language || "en-US";

          recognition.onresult = (event) => {
            let interimTranscript = "";
            for (let i = event.resultIndex; i < event.results.length; ++i) {
              const result = event.results[i];
              const transcript = result[0].transcript.trim();
              if (!transcript) continue;
              if (result.isFinal) {
                liveTranscript.textContent = "✔ " + transcript;
                processTranscript(transcript, true);
              } else {
                interimTranscript = transcript;
                liveTranscript.textContent = "… " + transcript;
                processTranscript(transcript, false);
              }
            }
            if (
              !interimTranscript &&
              !event.results[event.results.length - 1]?.isFinal
            ) {
              liveTranscript.textContent = "Listening…";
            }
          };

          recognition.onerror = (event) => {
            console.error("Speech recognition error", event.error);
            setStatus(`Error: ${event.error}`, false);
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = false;
            allowAutoRestart = false;
            isCapturing = false;
          };

          recognition.onend = () => {
            if (isCapturing && !isPaused && allowAutoRestart) {
              recognition.start();
            }
          };
        } catch (error) {
          console.error("❌ ERROR in setupRecognition:", error);
          recognitionInitialized = false;
          setStatus(
            "Failed to initialize speech recognition: " + error.message,
            false
          );
          startBtn.disabled = true;
        }
        console.log("=== SETUP RECOGNITION END ===");
      }

      // Event listeners
      startBtn.addEventListener("click", () => {
        if (!recognitionInitialized || !recognition) {
          setStatus(
            "Speech recognition not initialized. Check console (F12).",
            false
          );
          return;
        }
        recognition.lang = navigator.language || "en-US";
        allowAutoRestart = true;
        recognition.start();
        isCapturing = true;
        isPaused = false;
        setStatus("Listening… speak naturally.", true);
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
      });

      pauseBtn.addEventListener("click", () => {
        if (!recognition) return;
        if (!isPaused) {
          allowAutoRestart = false;
          recognition.stop();
          isPaused = true;
          pauseBtn.textContent = "▶ Resume";
          setStatus("Paused • resume when ready", false);
        } else {
          recognition.lang = navigator.language || "en-US";
          allowAutoRestart = true;
          recognition.start();
          isPaused = false;
          pauseBtn.textContent = "⏸ Pause";
          setStatus("Listening… speak naturally.", true);
        }
      });

      stopBtn.addEventListener("click", () => {
        if (recognition) {
          allowAutoRestart = false;
          recognition.stop();
        }
        resetSession();
      });

      contextBtn.addEventListener("click", () => {
        contextInput.click();
      });

      contextInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          console.log("📎 Context file selected:", file.name);
          // TODO: Process file for context
        }
      });

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          // TODO: Load session
        };
        reader.readAsText(file);
      });

      floatingNoteInput.addEventListener("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          const note = floatingNoteInput.value.trim();
          if (note) {
            console.log("📝 User input:", note);
            // Process as voice input - goes through same AI pipeline
            processTranscript(note, true);
            floatingNoteInput.value = "";
          }
        }
      });

      // Also allow Enter key for quick input
      floatingNoteInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter" && !event.metaKey && !event.ctrlKey) {
          event.preventDefault();
          const note = floatingNoteInput.value.trim();
          if (note) {
            console.log("📝 User input (Enter):", note);
            processTranscript(note, true);
            floatingNoteInput.value = "";
          }
        }
      });

      menuBtn.addEventListener("click", () => {
        alert(
          "Settings menu - Coming soon!\n\nOptions will include:\n- Font size\n- Map size\n- Language selection"
        );
      });

      // Initialize
      console.log("🔵 ====== STARTING INITIALIZATION ======");
      initMindMap();
      setupRecognition();
      resetSession();
      console.log("🔵 ====== INITIALIZATION COMPLETE ======");
    </script>
  </body>
</html>
